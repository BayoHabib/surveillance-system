
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>api: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">surveillance-core/internal/api/handlers.go (0.0%)</option>
				
				<option value="file1">surveillance-core/internal/core/alert_manager.go (95.7%)</option>
				
				<option value="file2">surveillance-core/internal/core/config.go (0.0%)</option>
				
				<option value="file3">surveillance-core/internal/core/errors.go (16.7%)</option>
				
				<option value="file4">surveillance-core/internal/core/event_processor.go (67.2%)</option>
				
				<option value="file5">surveillance-core/internal/vision/mock.go (84.6%)</option>
				
				<option value="file6">surveillance-core/internal/websocket/hub.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// internal/api/handlers.go
package api

import (
        "net/http"
        "strconv"
        "surveillance-core/internal/core"
        "surveillance-core/internal/vision"
        "sync"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

type Handler struct {
        visionClient   vision.Client
        eventProcessor core.EventProcessor
        alertManager   core.AlertManager
        cameras        map[string]*core.Camera
        mutex          sync.RWMutex
}

func NewHandler(visionClient vision.Client, eventProcessor core.EventProcessor, alertManager core.AlertManager) *Handler <span class="cov0" title="0">{
        handler := &amp;Handler{
                visionClient:   visionClient,
                eventProcessor: eventProcessor,
                alertManager:   alertManager,
                cameras:        make(map[string]*core.Camera),
        }

        // Ajouter quelques caméras par défaut pour le test
        handler.addDefaultCameras()

        return handler
}</span>

func (h *Handler) addDefaultCameras() <span class="cov0" title="0">{
        cameras := []*core.Camera{
                {
                        ID:       "cam_001",
                        Name:     "Entrée Principale",
                        URL:      "rtsp://mock/entrance",
                        Status:   core.CameraStatusOffline,
                        Location: "Entrée bâtiment A",
                        Config: core.CameraConfig{
                                Resolution:   core.Resolution{Width: 1920, Height: 1080},
                                FPS:          15,
                                Quality:      85,
                                EnableMotion: true,
                                EnableAI:     false,
                        },
                        CreatedAt: time.Now(),
                        Metadata:  map[string]string{"zone": "public", "priority": "high"},
                },
                {
                        ID:       "cam_002",
                        Name:     "Couloir Principal",
                        URL:      "rtsp://mock/corridor",
                        Status:   core.CameraStatusOffline,
                        Location: "Couloir niveau 1",
                        Config: core.CameraConfig{
                                Resolution:   core.Resolution{Width: 1280, Height: 720},
                                FPS:          30,
                                Quality:      75,
                                EnableMotion: true,
                                EnableAI:     true,
                        },
                        CreatedAt: time.Now(),
                        Metadata:  map[string]string{"zone": "restricted", "priority": "medium"},
                },
        }

        h.mutex.Lock()
        for _, camera := range cameras </span><span class="cov0" title="0">{
                h.cameras[camera.ID] = camera
        }</span>
        <span class="cov0" title="0">h.mutex.Unlock()</span>
}

// Endpoints cameras

func (h *Handler) GetCameras(c *gin.Context) <span class="cov0" title="0">{
        h.mutex.RLock()
        cameras := make([]*core.Camera, 0, len(h.cameras))
        for _, camera := range h.cameras </span><span class="cov0" title="0">{
                cameras = append(cameras, camera)
        }</span>
        <span class="cov0" title="0">h.mutex.RUnlock()

        c.JSON(http.StatusOK, gin.H{
                "cameras": cameras,
                "total":   len(cameras),
        })</span>
}

func (h *Handler) GetCamera(c *gin.Context) <span class="cov0" title="0">{
        cameraID := c.Param("id")

        h.mutex.RLock()
        camera, exists := h.cameras[cameraID]
        h.mutex.RUnlock()

        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "Caméra non trouvée"})
                return
        }</span>

        // Ajouter le statut du stream
        <span class="cov0" title="0">streamStatus := h.visionClient.GetStreamStatus(cameraID)
        response := gin.H{
                "camera":        camera,
                "stream_status": streamStatus,
        }

        c.JSON(http.StatusOK, response)</span>
}

func (h *Handler) CreateCamera(c *gin.Context) <span class="cov0" title="0">{
        var req struct {
                Name     string            `json:"name" binding:"required"`
                URL      string            `json:"url" binding:"required"`
                Location string            `json:"location"`
                Config   core.CameraConfig `json:"config"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">camera := &amp;core.Camera{
                ID:        uuid.New().String(),
                Name:      req.Name,
                URL:       req.URL,
                Status:    core.CameraStatusOffline,
                Location:  req.Location,
                Config:    req.Config,
                CreatedAt: time.Now(),
                Metadata:  make(map[string]string),
        }

        h.mutex.Lock()
        h.cameras[camera.ID] = camera
        h.mutex.Unlock()

        c.JSON(http.StatusCreated, camera)</span>
}

func (h *Handler) StartCamera(c *gin.Context) <span class="cov0" title="0">{
        cameraID := c.Param("id")

        h.mutex.Lock()
        camera, exists := h.cameras[cameraID]
        if !exists </span><span class="cov0" title="0">{
                h.mutex.Unlock()
                c.JSON(http.StatusNotFound, gin.H{"error": "Caméra non trouvée"})
                return
        }</span>

        // Vérifier si déjà en cours
        <span class="cov0" title="0">if camera.Status == core.CameraStatusStreaming </span><span class="cov0" title="0">{
                h.mutex.Unlock()
                c.JSON(http.StatusConflict, gin.H{"error": "Caméra déjà en cours de streaming"})
                return
        }</span>

        <span class="cov0" title="0">camera.Status = core.CameraStatusOnline
        h.mutex.Unlock()

        // Démarrer le stream
        framesChan, err := h.visionClient.StartStream(cameraID)
        if err != nil </span><span class="cov0" title="0">{
                h.mutex.Lock()
                camera.Status = core.CameraStatusError
                h.mutex.Unlock()

                c.JSON(http.StatusInternalServerError, gin.H{"error": "Impossible de démarrer le stream"})
                return
        }</span>

        // Traiter les frames en arrière-plan
        <span class="cov0" title="0">go h.processFrames(cameraID, framesChan)

        h.mutex.Lock()
        camera.Status = core.CameraStatusStreaming
        now := time.Now()
        camera.LastFrame = &amp;now
        h.mutex.Unlock()

        c.JSON(http.StatusOK, gin.H{
                "message": "Stream démarré",
                "camera":  camera,
        })</span>
}

func (h *Handler) StopCamera(c *gin.Context) <span class="cov0" title="0">{
        cameraID := c.Param("id")

        h.mutex.Lock()
        camera, exists := h.cameras[cameraID]
        if !exists </span><span class="cov0" title="0">{
                h.mutex.Unlock()
                c.JSON(http.StatusNotFound, gin.H{"error": "Caméra non trouvée"})
                return
        }</span>
        <span class="cov0" title="0">h.mutex.Unlock()

        // Arrêter le stream
        err := h.visionClient.StopStream(cameraID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Erreur arrêt stream"})
                return
        }</span>

        <span class="cov0" title="0">h.mutex.Lock()
        camera.Status = core.CameraStatusOffline
        h.mutex.Unlock()

        c.JSON(http.StatusOK, gin.H{
                "message": "Stream arrêté",
                "camera":  camera,
        })</span>
}

// Endpoint alertes

func (h *Handler) GetAlerts(c *gin.Context) <span class="cov0" title="0">{
        // Paramètres de pagination
        limitStr := c.DefaultQuery("limit", "50")
        offsetStr := c.DefaultQuery("offset", "0")
        cameraID := c.Query("camera_id")

        limit, _ := strconv.Atoi(limitStr)
        offset, _ := strconv.Atoi(offsetStr)

        var alerts []core.Alert
        if cameraID != "" </span><span class="cov0" title="0">{
                alerts = h.alertManager.GetAlertsByCamera(cameraID)
        }</span> else<span class="cov0" title="0"> {
                alerts = h.alertManager.GetAlerts(limit, offset)
        }</span>

        <span class="cov0" title="0">stats := h.alertManager.GetAlertStats()

        c.JSON(http.StatusOK, gin.H{
                "alerts": alerts,
                "stats":  stats,
                "pagination": gin.H{
                        "limit":  limit,
                        "offset": offset,
                        "total":  stats.Total,
                },
        })</span>
}

// Endpoint santé

func (h *Handler) Health(c *gin.Context) <span class="cov0" title="0">{
        visionConnected := h.visionClient.IsConnected()
        processorStats := h.eventProcessor.GetStats()

        status := "healthy"
        if !visionConnected </span><span class="cov0" title="0">{
                status = "degraded"
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "status":           status,
                "timestamp":        time.Now(),
                "vision_connected": visionConnected,
                "processor_stats":  processorStats,
                "cameras_count":    len(h.cameras),
        })</span>
}

// Traitement des frames en arrière-plan

func (h *Handler) processFrames(cameraID string, framesChan &lt;-chan core.Frame) <span class="cov0" title="0">{
        for frame := range framesChan </span><span class="cov0" title="0">{
                // Mettre à jour timestamp dernière frame
                h.mutex.Lock()
                if camera, exists := h.cameras[cameraID]; exists </span><span class="cov0" title="0">{
                        camera.LastFrame = &amp;frame.Timestamp
                }</span>
                <span class="cov0" title="0">h.mutex.Unlock()

                // Ici on pourrait appeler l'EventProcessor avec des détections
                // Pour le moment, on simule juste la réception des frames

                // Log toutes les 5 secondes pour éviter le spam
                if frame.Timestamp.Second()%5 == 0 </span><span class="cov0" title="0">{
                        println("📹 Frame reçue de", cameraID, "taille:", frame.Size, "bytes")
                }</span>
        }

        // Stream fermé
        <span class="cov0" title="0">h.mutex.Lock()
        if camera, exists := h.cameras[cameraID]; exists </span><span class="cov0" title="0">{
                camera.Status = core.CameraStatusOffline
        }</span>
        <span class="cov0" title="0">h.mutex.Unlock()

        println("🛑 Stream fermé pour", cameraID)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// internal/core/alert_manager.go
package core

import (
        "errors"
        "log"
        "sync"
        "time"
)

type AlertManager interface {
        AddAlert(alert Alert)
        GetAlerts(limit int, offset int) []Alert
        GetAlertsByCamera(cameraID string) []Alert
        AcknowledgeAlert(alertID, userID string) error
        GetAlertStats() AlertStats
        CleanupOldAlerts()
}

type AlertStats struct {
        Total        int                `json:"total"`
        Acknowledged int                `json:"acknowledged"`
        Pending      int                `json:"pending"`
        ByLevel      map[AlertLevel]int `json:"by_level"`
        ByType       map[AlertType]int  `json:"by_type"`
}

type alertManager struct {
        alerts    []Alert
        retention time.Duration
        mutex     sync.RWMutex
}

func NewAlertManager(retention time.Duration) AlertManager <span class="cov8" title="1">{
        am := &amp;alertManager{
                alerts:    make([]Alert, 0),
                retention: retention,
        }

        // Nettoyage périodique des anciennes alertes
        go am.periodicCleanup()

        return am
}</span>

func (am *alertManager) AddAlert(alert Alert) <span class="cov8" title="1">{
        // Sanitizer et valider
        SanitizeAlert(&amp;alert)
        if validation := ValidateAlert(&amp;alert); validation.HasErrors() </span><span class="cov0" title="0">{
                log.Printf("Invalid alert: %v", validation.Errors)
                return
        }</span>
        <span class="cov8" title="1">am.mutex.Lock()
        defer am.mutex.Unlock()

        // Insertion triée par timestamp (plus récent en premier)
        insertIndex := 0
        for i, existingAlert := range am.alerts </span><span class="cov8" title="1">{
                if alert.Timestamp.After(existingAlert.Timestamp) </span><span class="cov8" title="1">{
                        insertIndex = i
                        break</span>
                }
                <span class="cov8" title="1">insertIndex = i + 1</span>
        }

        // Insertion à l'index calculé
        <span class="cov8" title="1">am.alerts = append(am.alerts, Alert{})
        copy(am.alerts[insertIndex+1:], am.alerts[insertIndex:])
        am.alerts[insertIndex] = alert</span>
}

func (am *alertManager) GetAlerts(limit int, offset int) []Alert <span class="cov8" title="1">{
        am.mutex.RLock()
        defer am.mutex.RUnlock()

        if offset &gt;= len(am.alerts) </span><span class="cov8" title="1">{
                return []Alert{}
        }</span>

        <span class="cov8" title="1">end := offset + limit
        if end &gt; len(am.alerts) </span><span class="cov8" title="1">{
                end = len(am.alerts)
        }</span>

        // Copie pour éviter les races conditions
        <span class="cov8" title="1">result := make([]Alert, end-offset)
        copy(result, am.alerts[offset:end])

        return result</span>
}

func (am *alertManager) GetAlertsByCamera(cameraID string) []Alert <span class="cov8" title="1">{
        am.mutex.RLock()
        defer am.mutex.RUnlock()

        var result []Alert
        for _, alert := range am.alerts </span><span class="cov8" title="1">{
                if alert.CameraID == cameraID </span><span class="cov8" title="1">{
                        result = append(result, alert)
                }</span>
        }

        <span class="cov8" title="1">return result</span>
}

func (am *alertManager) AcknowledgeAlert(alertID, userID string) error <span class="cov8" title="1">{
        am.mutex.Lock()
        defer am.mutex.Unlock()

        for i := range am.alerts </span><span class="cov8" title="1">{
                if am.alerts[i].ID == alertID </span><span class="cov8" title="1">{
                        now := time.Now()
                        am.alerts[i].Acknowledged = true
                        am.alerts[i].AckedBy = userID
                        am.alerts[i].AckedAt = &amp;now
                        return nil
                }</span>
        }

        <span class="cov8" title="1">return ErrAlertNotFound</span>
}

func (am *alertManager) GetAlertStats() AlertStats <span class="cov8" title="1">{
        am.mutex.RLock()
        defer am.mutex.RUnlock()

        stats := AlertStats{
                Total:   len(am.alerts),
                ByLevel: make(map[AlertLevel]int),
                ByType:  make(map[AlertType]int),
        }

        for _, alert := range am.alerts </span><span class="cov8" title="1">{
                if alert.Acknowledged </span><span class="cov8" title="1">{
                        stats.Acknowledged++
                }</span> else<span class="cov8" title="1"> {
                        stats.Pending++
                }</span>

                <span class="cov8" title="1">stats.ByLevel[alert.Level]++
                stats.ByType[alert.Type]++</span>
        }

        <span class="cov8" title="1">return stats</span>
}

func (am *alertManager) CleanupOldAlerts() <span class="cov8" title="1">{
        am.mutex.Lock()
        defer am.mutex.Unlock()

        cutoff := time.Now().Add(-am.retention)

        // Filtrer les alertes récentes
        filtered := make([]Alert, 0)
        for _, alert := range am.alerts </span><span class="cov8" title="1">{
                if alert.Timestamp.After(cutoff) </span><span class="cov8" title="1">{
                        filtered = append(filtered, alert)
                }</span>
        }

        <span class="cov8" title="1">removed := len(am.alerts) - len(filtered)
        am.alerts = filtered

        if removed &gt; 0 </span><span class="cov8" title="1">{
                log.Printf("Nettoyage: %d alertes supprimées", removed)
        }</span>
}

func (am *alertManager) periodicCleanup() <span class="cov8" title="1">{
        ticker := time.NewTicker(time.Hour)
        defer ticker.Stop()

        for range ticker.C </span><span class="cov0" title="0">{
                am.CleanupOldAlerts()
        }</span>
}

// Erreurs
var (
        ErrAlertNotFound = errors.New("alerte non trouvée")
)
</pre>
		
		<pre class="file" id="file2" style="display: none">// internal/core/config.go
package core

import (
        "fmt"
        "os"
        "strconv"
        "strings"
        "time"
)

// Config représente la configuration globale améliorée
type Config struct {
        // Serveur
        Server ServerConfig `json:"server"`

        // Services externes
        VisionService VisionServiceConfig `json:"vision_service"`

        // Base de données
        Database DatabaseConfig `json:"database"`

        // Caméras
        Cameras CameraManagerConfig `json:"cameras"`

        // Alertes
        Alerts AlertConfig `json:"alerts"`

        // Logs
        Logging LoggingConfig `json:"logging"`

        // Sécurité
        Security SecurityConfig `json:"security"`
}

type ServerConfig struct {
        Port            string        `json:"port"`
        Host            string        `json:"host"`
        ReadTimeout     time.Duration `json:"read_timeout"`
        WriteTimeout    time.Duration `json:"write_timeout"`
        ShutdownTimeout time.Duration `json:"shutdown_timeout"`
        TLSEnabled      bool          `json:"tls_enabled"`
        CertFile        string        `json:"cert_file"`
        KeyFile         string        `json:"key_file"`
}

type VisionServiceConfig struct {
        Address             string        `json:"address"`
        Timeout             time.Duration `json:"timeout"`
        MaxRetries          int           `json:"max_retries"`
        RetryInterval       time.Duration `json:"retry_interval"`
        HealthCheckInterval time.Duration `json:"health_check_interval"`
}

type CameraManagerConfig struct {
        MaxCameras           int           `json:"max_cameras"`
        DefaultFPS           int           `json:"default_fps"`
        DefaultQuality       int           `json:"default_quality"`
        StreamTimeout        time.Duration `json:"stream_timeout"`
        ReconnectDelay       time.Duration `json:"reconnect_delay"`
        MaxReconnectAttempts int           `json:"max_reconnect_attempts"`
}

type AlertConfig struct {
        Retention            time.Duration         `json:"retention"`
        MaxAlerts            int                   `json:"max_alerts"`
        NotificationChannels []NotificationChannel `json:"notification_channels"`
        ThrottleInterval     time.Duration         `json:"throttle_interval"`
        BatchSize            int                   `json:"batch_size"`
}

type NotificationChannel struct {
        Name    string            `json:"name"`
        Type    string            `json:"type"` // "email", "webhook", "sms"
        Enabled bool              `json:"enabled"`
        Config  map[string]string `json:"config"`
        Filters []AlertFilter     `json:"filters"`
}

type AlertFilter struct {
        Level    AlertLevel `json:"level,omitempty"`
        Type     AlertType  `json:"type,omitempty"`
        CameraID string     `json:"camera_id,omitempty"`
}

type LoggingConfig struct {
        Level      string `json:"level"`
        Format     string `json:"format"` // "json", "text"
        Output     string `json:"output"` // "stdout", "file", "both"
        File       string `json:"file"`
        MaxSize    int    `json:"max_size"` // MB
        MaxAge     int    `json:"max_age"`  // Days
        MaxBackups int    `json:"max_backups"`
        Compress   bool   `json:"compress"`
}

type SecurityConfig struct {
        JWTSecret        string        `json:"jwt_secret"`
        JWTExpiry        time.Duration `json:"jwt_expiry"`
        RateLimitEnabled bool          `json:"rate_limit_enabled"`
        RateLimitRPS     int           `json:"rate_limit_rps"`
        CORSEnabled      bool          `json:"cors_enabled"`
        CORSOrigins      []string      `json:"cors_origins"`
}

// LoadConfig charge la configuration depuis les variables d'environnement avec des valeurs par défaut
func LoadConfig() (*Config, error) <span class="cov0" title="0">{
        config := getDefaultConfig()

        // Charger depuis les variables d'environnement
        if err := loadFromEnv(config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to load config from environment: %w", err)
        }</span>

        // Valider la configuration
        <span class="cov0" title="0">if err := validateConfig(config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid configuration: %w", err)
        }</span>

        <span class="cov0" title="0">return config, nil</span>
}

// getDefaultConfig retourne une configuration par défaut
func getDefaultConfig() *Config <span class="cov0" title="0">{
        return &amp;Config{
                Server: ServerConfig{
                        Port:            ":8080",
                        Host:            "0.0.0.0",
                        ReadTimeout:     15 * time.Second,
                        WriteTimeout:    15 * time.Second,
                        ShutdownTimeout: 5 * time.Second,
                        TLSEnabled:      false,
                },
                VisionService: VisionServiceConfig{
                        Address:             "localhost:50051",
                        Timeout:             30 * time.Second,
                        MaxRetries:          3,
                        RetryInterval:       5 * time.Second,
                        HealthCheckInterval: 30 * time.Second,
                },
                Database: DatabaseConfig{
                        Type:     "sqlite",
                        URL:      "surveillance.db",
                        MaxConns: 10,
                },
                Cameras: CameraManagerConfig{
                        MaxCameras:           10,
                        DefaultFPS:           15,
                        DefaultQuality:       75,
                        StreamTimeout:        30 * time.Second,
                        ReconnectDelay:       5 * time.Second,
                        MaxReconnectAttempts: 5,
                },
                Alerts: AlertConfig{
                        Retention:        24 * time.Hour,
                        MaxAlerts:        1000,
                        ThrottleInterval: 30 * time.Second,
                        BatchSize:        10,
                        NotificationChannels: []NotificationChannel{
                                {
                                        Name:    "default",
                                        Type:    "webhook",
                                        Enabled: false,
                                        Config:  map[string]string{},
                                },
                        },
                },
                Logging: LoggingConfig{
                        Level:      "info",
                        Format:     "text",
                        Output:     "stdout",
                        MaxSize:    10,
                        MaxAge:     7,
                        MaxBackups: 3,
                        Compress:   true,
                },
                Security: SecurityConfig{
                        JWTSecret:        "change-me-in-production",
                        JWTExpiry:        24 * time.Hour,
                        RateLimitEnabled: true,
                        RateLimitRPS:     100,
                        CORSEnabled:      true,
                        CORSOrigins:      []string{"*"},
                },
        }
}</span>

// loadFromEnv charge les valeurs depuis les variables d'environnement
func loadFromEnv(config *Config) error <span class="cov0" title="0">{
        // Serveur
        if port := os.Getenv("PORT"); port != "" </span><span class="cov0" title="0">{
                if !strings.HasPrefix(port, ":") </span><span class="cov0" title="0">{
                        port = ":" + port
                }</span>
                <span class="cov0" title="0">config.Server.Port = port</span>
        }
        <span class="cov0" title="0">if host := os.Getenv("HOST"); host != "" </span><span class="cov0" title="0">{
                config.Server.Host = host
        }</span>
        <span class="cov0" title="0">if tlsStr := os.Getenv("TLS_ENABLED"); tlsStr != "" </span><span class="cov0" title="0">{
                if tls, err := strconv.ParseBool(tlsStr); err == nil </span><span class="cov0" title="0">{
                        config.Server.TLSEnabled = tls
                }</span>
        }
        <span class="cov0" title="0">if certFile := os.Getenv("TLS_CERT_FILE"); certFile != "" </span><span class="cov0" title="0">{
                config.Server.CertFile = certFile
        }</span>
        <span class="cov0" title="0">if keyFile := os.Getenv("TLS_KEY_FILE"); keyFile != "" </span><span class="cov0" title="0">{
                config.Server.KeyFile = keyFile
        }</span>

        // Service Vision
        <span class="cov0" title="0">if addr := os.Getenv("VISION_SERVICE_ADDRESS"); addr != "" </span><span class="cov0" title="0">{
                config.VisionService.Address = addr
        }</span>
        <span class="cov0" title="0">if timeoutStr := os.Getenv("VISION_SERVICE_TIMEOUT"); timeoutStr != "" </span><span class="cov0" title="0">{
                if timeout, err := time.ParseDuration(timeoutStr); err == nil </span><span class="cov0" title="0">{
                        config.VisionService.Timeout = timeout
                }</span>
        }

        // Base de données
        <span class="cov0" title="0">if dbType := os.Getenv("DB_TYPE"); dbType != "" </span><span class="cov0" title="0">{
                config.Database.Type = dbType
        }</span>
        <span class="cov0" title="0">if dbURL := os.Getenv("DB_URL"); dbURL != "" </span><span class="cov0" title="0">{
                config.Database.URL = dbURL
        }</span>
        <span class="cov0" title="0">if maxConnsStr := os.Getenv("DB_MAX_CONNS"); maxConnsStr != "" </span><span class="cov0" title="0">{
                if maxConns, err := strconv.Atoi(maxConnsStr); err == nil </span><span class="cov0" title="0">{
                        config.Database.MaxConns = maxConns
                }</span>
        }

        // Caméras
        <span class="cov0" title="0">if maxCamsStr := os.Getenv("MAX_CAMERAS"); maxCamsStr != "" </span><span class="cov0" title="0">{
                if maxCams, err := strconv.Atoi(maxCamsStr); err == nil </span><span class="cov0" title="0">{
                        config.Cameras.MaxCameras = maxCams
                }</span>
        }
        <span class="cov0" title="0">if defaultFPSStr := os.Getenv("DEFAULT_FPS"); defaultFPSStr != "" </span><span class="cov0" title="0">{
                if fps, err := strconv.Atoi(defaultFPSStr); err == nil </span><span class="cov0" title="0">{
                        config.Cameras.DefaultFPS = fps
                }</span>
        }

        // Alertes
        <span class="cov0" title="0">if retentionStr := os.Getenv("ALERT_RETENTION"); retentionStr != "" </span><span class="cov0" title="0">{
                if retention, err := time.ParseDuration(retentionStr); err == nil </span><span class="cov0" title="0">{
                        config.Alerts.Retention = retention
                }</span>
        }
        <span class="cov0" title="0">if maxAlertsStr := os.Getenv("MAX_ALERTS"); maxAlertsStr != "" </span><span class="cov0" title="0">{
                if maxAlerts, err := strconv.Atoi(maxAlertsStr); err == nil </span><span class="cov0" title="0">{
                        config.Alerts.MaxAlerts = maxAlerts
                }</span>
        }

        // Logs
        <span class="cov0" title="0">if level := os.Getenv("LOG_LEVEL"); level != "" </span><span class="cov0" title="0">{
                config.Logging.Level = level
        }</span>
        <span class="cov0" title="0">if format := os.Getenv("LOG_FORMAT"); format != "" </span><span class="cov0" title="0">{
                config.Logging.Format = format
        }</span>
        <span class="cov0" title="0">if output := os.Getenv("LOG_OUTPUT"); output != "" </span><span class="cov0" title="0">{
                config.Logging.Output = output
        }</span>
        <span class="cov0" title="0">if file := os.Getenv("LOG_FILE"); file != "" </span><span class="cov0" title="0">{
                config.Logging.File = file
        }</span>

        // Sécurité
        <span class="cov0" title="0">if secret := os.Getenv("JWT_SECRET"); secret != "" </span><span class="cov0" title="0">{
                config.Security.JWTSecret = secret
        }</span>
        <span class="cov0" title="0">if expiryStr := os.Getenv("JWT_EXPIRY"); expiryStr != "" </span><span class="cov0" title="0">{
                if expiry, err := time.ParseDuration(expiryStr); err == nil </span><span class="cov0" title="0">{
                        config.Security.JWTExpiry = expiry
                }</span>
        }
        <span class="cov0" title="0">if rateLimitStr := os.Getenv("RATE_LIMIT_ENABLED"); rateLimitStr != "" </span><span class="cov0" title="0">{
                if enabled, err := strconv.ParseBool(rateLimitStr); err == nil </span><span class="cov0" title="0">{
                        config.Security.RateLimitEnabled = enabled
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// validateConfig valide la configuration
func validateConfig(config *Config) error <span class="cov0" title="0">{
        // Valider le port
        if config.Server.Port == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("server port is required")
        }</span>

        // Valider TLS
        <span class="cov0" title="0">if config.Server.TLSEnabled </span><span class="cov0" title="0">{
                if config.Server.CertFile == "" || config.Server.KeyFile == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("TLS cert and key files required when TLS is enabled")
                }</span>
        }

        // Valider le service Vision
        <span class="cov0" title="0">if config.VisionService.Address == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("vision service address is required")
        }</span>

        // Valider les caméras
        <span class="cov0" title="0">if config.Cameras.MaxCameras &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("max cameras must be positive")
        }</span>
        <span class="cov0" title="0">if config.Cameras.DefaultFPS &lt;= 0 || config.Cameras.DefaultFPS &gt; 120 </span><span class="cov0" title="0">{
                return fmt.Errorf("default FPS must be between 1 and 120")
        }</span>

        // Valider les alertes
        <span class="cov0" title="0">if config.Alerts.Retention &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("alert retention must be positive")
        }</span>
        <span class="cov0" title="0">if config.Alerts.MaxAlerts &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("max alerts must be positive")
        }</span>

        // Valider les logs
        <span class="cov0" title="0">validLogLevels := map[string]bool{
                "debug": true, "info": true, "warn": true, "error": true,
        }
        if !validLogLevels[config.Logging.Level] </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid log level: %s", config.Logging.Level)
        }</span>

        // Valider la sécurité
        <span class="cov0" title="0">if config.Security.JWTSecret == "change-me-in-production" </span><span class="cov0" title="0">{
                fmt.Println("WARNING: Using default JWT secret in production is insecure!")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// IsDevelopment retourne true si l'environnement est en développement
func (c *Config) IsDevelopment() bool <span class="cov0" title="0">{
        env := strings.ToLower(os.Getenv("ENV"))
        return env == "dev" || env == "development" || env == ""
}</span>

// IsProduction retourne true si l'environnement est en production
func (c *Config) IsProduction() bool <span class="cov0" title="0">{
        env := strings.ToLower(os.Getenv("ENV"))
        return env == "prod" || env == "production"
}</span>

// GetServerAddress retourne l'adresse complète du serveur
func (c *Config) GetServerAddress() string <span class="cov0" title="0">{
        return c.Server.Host + c.Server.Port
}</span>

// String retourne une représentation string de la config (sans secrets)
func (c *Config) String() string <span class="cov0" title="0">{
        safeConfig := *c
        safeConfig.Security.JWTSecret = "[REDACTED]"

        return fmt.Sprintf("Config{Server: %+v, Cameras: %+v, Alerts: %+v}",
                safeConfig.Server, safeConfig.Cameras, safeConfig.Alerts)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">// internal/core/errors.go
package core

import (
        "errors"
        "fmt"
        "net/url"
        "strings"
)

// Erreurs système personnalisées
var (
        ErrCameraNotFound       = errors.New("camera not found")
        ErrCameraAlreadyExists  = errors.New("camera already exists")
        ErrStreamNotFound       = errors.New("stream not found")
        ErrStreamAlreadyActive  = errors.New("stream already active")
        ErrInvalidCameraID      = errors.New("invalid camera ID")
        ErrInvalidURL           = errors.New("invalid camera URL")
        ErrInvalidConfiguration = errors.New("invalid configuration")
        //ErrAlertNotFound      = errors.New("alert not found")
        ErrDetectorNotFound   = errors.New("detector not found")
        ErrInvalidDetection   = errors.New("invalid detection data")
        ErrServiceUnavailable = errors.New("service unavailable")
)

// SystemError représente une erreur avec contexte
type SystemError struct {
        Code    string
        Message string
        Cause   error
        Context map[string]interface{}
}

func (e *SystemError) Error() string <span class="cov0" title="0">{
        if e.Cause != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s: %s (caused by: %v)", e.Code, e.Message, e.Cause)
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%s: %s", e.Code, e.Message)</span>
}

func (e *SystemError) Unwrap() error <span class="cov0" title="0">{
        return e.Cause
}</span>

// Constructeurs d'erreurs avec contexte
func NewCameraError(code, message string, cause error, cameraID string) *SystemError <span class="cov0" title="0">{
        return &amp;SystemError{
                Code:    code,
                Message: message,
                Cause:   cause,
                Context: map[string]interface{}{
                        "camera_id": cameraID,
                },
        }
}</span>

func NewStreamError(code, message string, cause error, cameraID string, streamStatus StreamStatus) *SystemError <span class="cov0" title="0">{
        return &amp;SystemError{
                Code:    code,
                Message: message,
                Cause:   cause,
                Context: map[string]interface{}{
                        "camera_id":     cameraID,
                        "stream_status": streamStatus,
                },
        }
}</span>

func NewValidationError(field, message string, value interface{}) *SystemError <span class="cov0" title="0">{
        return &amp;SystemError{
                Code:    "VALIDATION_ERROR",
                Message: fmt.Sprintf("validation failed for field '%s': %s", field, message),
                Context: map[string]interface{}{
                        "field": field,
                        "value": value,
                },
        }
}</span>

// ValidationResult représente le résultat d'une validation
type ValidationResult struct {
        Valid  bool
        Errors []ValidationError
}

type ValidationError struct {
        Field   string      `json:"field"`
        Message string      `json:"message"`
        Value   interface{} `json:"value,omitempty"`
}

func (vr *ValidationResult) AddError(field, message string, value interface{}) <span class="cov0" title="0">{
        vr.Valid = false
        vr.Errors = append(vr.Errors, ValidationError{
                Field:   field,
                Message: message,
                Value:   value,
        })
}</span>

func (vr *ValidationResult) HasErrors() bool <span class="cov8" title="1">{
        return len(vr.Errors) &gt; 0
}</span>

// Validateurs

// ValidateCamera valide les données d'une caméra
func ValidateCamera(camera *Camera) *ValidationResult <span class="cov0" title="0">{
        result := &amp;ValidationResult{Valid: true}

        // ID requis et format valide
        if camera.ID == "" </span><span class="cov0" title="0">{
                result.AddError("id", "camera ID is required", camera.ID)
        }</span> else<span class="cov0" title="0"> if len(camera.ID) &lt; 3 || len(camera.ID) &gt; 50 </span><span class="cov0" title="0">{
                result.AddError("id", "camera ID must be between 3 and 50 characters", camera.ID)
        }</span> else<span class="cov0" title="0"> if !isValidCameraID(camera.ID) </span><span class="cov0" title="0">{
                result.AddError("id", "camera ID contains invalid characters", camera.ID)
        }</span>

        // Nom requis
        <span class="cov0" title="0">if camera.Name == "" </span><span class="cov0" title="0">{
                result.AddError("name", "camera name is required", camera.Name)
        }</span> else<span class="cov0" title="0"> if len(camera.Name) &gt; 100 </span><span class="cov0" title="0">{
                result.AddError("name", "camera name must be less than 100 characters", camera.Name)
        }</span>

        // URL valide
        <span class="cov0" title="0">if camera.URL == "" </span><span class="cov0" title="0">{
                result.AddError("url", "camera URL is required", camera.URL)
        }</span> else<span class="cov0" title="0"> if !isValidCameraURL(camera.URL) </span><span class="cov0" title="0">{
                result.AddError("url", "camera URL format is invalid", camera.URL)
        }</span>

        // Configuration
        <span class="cov0" title="0">if err := validateCameraConfig(&amp;camera.Config); err != nil </span><span class="cov0" title="0">{
                result.AddError("config", err.Error(), camera.Config)
        }</span>

        <span class="cov0" title="0">return result</span>
}

// ValidateDetection valide une détection
func ValidateDetection(detection *Detection) *ValidationResult <span class="cov0" title="0">{
        result := &amp;ValidationResult{Valid: true}

        // ID requis
        if detection.ID == "" </span><span class="cov0" title="0">{
                result.AddError("id", "detection ID is required", detection.ID)
        }</span>

        // Camera ID requis
        <span class="cov0" title="0">if detection.CameraID == "" </span><span class="cov0" title="0">{
                result.AddError("camera_id", "camera ID is required", detection.CameraID)
        }</span>

        // Type valide
        <span class="cov0" title="0">if !isValidDetectionType(detection.Type) </span><span class="cov0" title="0">{
                result.AddError("type", "invalid detection type", detection.Type)
        }</span>

        // Confiance entre 0 et 1
        <span class="cov0" title="0">if detection.Confidence &lt; 0 || detection.Confidence &gt; 1 </span><span class="cov0" title="0">{
                result.AddError("confidence", "confidence must be between 0 and 1", detection.Confidence)
        }</span>

        // Bounding box valide
        <span class="cov0" title="0">if detection.BBox.Width &lt;= 0 || detection.BBox.Height &lt;= 0 </span><span class="cov0" title="0">{
                result.AddError("bbox", "bounding box dimensions must be positive", detection.BBox)
        }</span>

        // Timestamp valide
        <span class="cov0" title="0">if detection.Timestamp.IsZero() </span><span class="cov0" title="0">{
                result.AddError("timestamp", "timestamp is required", detection.Timestamp)
        }</span>

        <span class="cov0" title="0">return result</span>
}

// ValidateAlert valide une alerte
func ValidateAlert(alert *Alert) *ValidationResult <span class="cov8" title="1">{
        result := &amp;ValidationResult{Valid: true}

        // ID requis
        if alert.ID == "" </span><span class="cov0" title="0">{
                result.AddError("id", "alert ID is required", alert.ID)
        }</span>

        // Camera ID requis
        <span class="cov8" title="1">if alert.CameraID == "" </span><span class="cov0" title="0">{
                result.AddError("camera_id", "camera ID is required", alert.CameraID)
        }</span>

        // Type valide
        <span class="cov8" title="1">if !isValidAlertType(alert.Type) </span><span class="cov0" title="0">{
                result.AddError("type", "invalid alert type", alert.Type)
        }</span>

        // Niveau valide
        <span class="cov8" title="1">if !isValidAlertLevel(alert.Level) </span><span class="cov0" title="0">{
                result.AddError("level", "invalid alert level", alert.Level)
        }</span>

        // Message requis
        <span class="cov8" title="1">if alert.Message == "" </span><span class="cov0" title="0">{
                result.AddError("message", "alert message is required", alert.Message)
        }</span>

        // Timestamp valide
        <span class="cov8" title="1">if alert.Timestamp.IsZero() </span><span class="cov0" title="0">{
                result.AddError("timestamp", "timestamp is required", alert.Timestamp)
        }</span>

        <span class="cov8" title="1">return result</span>
}

// Fonctions utilitaires de validation

func isValidCameraID(id string) bool <span class="cov0" title="0">{
        // Autorise lettres, chiffres, tirets et underscores
        for _, r := range id </span><span class="cov0" title="0">{
                if !((r &gt;= 'a' &amp;&amp; r &lt;= 'z') || (r &gt;= 'A' &amp;&amp; r &lt;= 'Z') ||
                        (r &gt;= '0' &amp;&amp; r &lt;= '9') || r == '-' || r == '_') </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

func isValidCameraURL(urlStr string) bool <span class="cov0" title="0">{
        // Vérifier le format de base de l'URL
        u, err := url.Parse(urlStr)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Accepter différents schémas
        <span class="cov0" title="0">validSchemes := map[string]bool{
                "http":  true,
                "https": true,
                "rtsp":  true,
                "rtmp":  true,
                "mock":  true, // Pour les tests
        }

        return validSchemes[strings.ToLower(u.Scheme)]</span>
}

func validateCameraConfig(config *CameraConfig) error <span class="cov0" title="0">{
        // Résolution valide
        if config.Resolution.Width &lt;= 0 || config.Resolution.Height &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("resolution must have positive dimensions")
        }</span>
        <span class="cov0" title="0">if config.Resolution.Width &gt; 7680 || config.Resolution.Height &gt; 4320 </span><span class="cov0" title="0">{ // 8K max
                return fmt.Errorf("resolution exceeds maximum supported (8K)")
        }</span>

        // FPS valide
        <span class="cov0" title="0">if config.FPS &lt;= 0 || config.FPS &gt; 120 </span><span class="cov0" title="0">{
                return fmt.Errorf("FPS must be between 1 and 120")
        }</span>

        // Qualité valide
        <span class="cov0" title="0">if config.Quality &lt; 1 || config.Quality &gt; 100 </span><span class="cov0" title="0">{
                return fmt.Errorf("quality must be between 1 and 100")
        }</span>

        // Valider les zones
        <span class="cov0" title="0">for i, zone := range config.Zones </span><span class="cov0" title="0">{
                if zone.ID == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("zone %d must have an ID", i)
                }</span>
                <span class="cov0" title="0">if zone.Name == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("zone %d must have a name", i)
                }</span>
                <span class="cov0" title="0">if len(zone.Points) &lt; 3 </span><span class="cov0" title="0">{
                        return fmt.Errorf("zone %d must have at least 3 points", i)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func isValidDetectionType(detType DetectionType) bool <span class="cov0" title="0">{
        validTypes := map[DetectionType]bool{
                DetectionTypeMotion:    true,
                DetectionTypePerson:    true,
                DetectionTypeFace:      true,
                DetectionTypeVehicle:   true,
                DetectionTypeObject:    true,
                DetectionTypeIntrusion: true,
        }
        return validTypes[detType]
}</span>

func isValidAlertType(alertType AlertType) bool <span class="cov8" title="1">{
        validTypes := map[AlertType]bool{
                AlertTypeMotion:    true,
                AlertTypeIntrusion: true,
                AlertTypeFace:      true,
                AlertTypeSystem:    true,
        }
        return validTypes[alertType]
}</span>

func isValidAlertLevel(level AlertLevel) bool <span class="cov8" title="1">{
        validLevels := map[AlertLevel]bool{
                AlertLevelInfo:     true,
                AlertLevelWarning:  true,
                AlertLevelCritical: true,
                AlertLevelUrgent:   true,
        }
        return validLevels[level]
}</span>

// Sanitizers pour nettoyer les données

func SanitizeCamera(camera *Camera) <span class="cov0" title="0">{
        camera.Name = strings.TrimSpace(camera.Name)
        camera.Location = strings.TrimSpace(camera.Location)
        camera.URL = strings.TrimSpace(camera.URL)

        // Nettoyer les métadonnées
        for key, value := range camera.Metadata </span><span class="cov0" title="0">{
                camera.Metadata[key] = strings.TrimSpace(value)
        }</span>
}

func SanitizeAlert(alert *Alert) <span class="cov8" title="1">{
        alert.Message = strings.TrimSpace(alert.Message)
        alert.AckedBy = strings.TrimSpace(alert.AckedBy)

        // Nettoyer les métadonnées
        for key, value := range alert.Metadata </span><span class="cov0" title="0">{
                alert.Metadata[key] = strings.TrimSpace(value)
        }</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// internal/core/event_processor.go
package core

import (
        "fmt"
        "log"
        "sync"
        "time"

        "github.com/google/uuid"
)

type EventProcessor interface {
        ProcessDetection(detection Detection) []Alert
        RegisterDetector(name string, detector Detector)
        SetAlertCallback(callback func(Alert))
        GetStats() ProcessorStats
}

type Detector interface {
        ShouldAlert(detection Detection) bool
        CreateAlert(detection Detection) Alert
}

type ProcessorStats struct {
        TotalDetections int64     `json:"total_detections"`
        TotalAlerts     int64     `json:"total_alerts"`
        LastProcessed   time.Time `json:"last_processed"`
        ProcessingRate  float64   `json:"processing_rate"` // détections/seconde
}

type eventProcessor struct {
        detectors     map[string]Detector
        alertCallback func(Alert)
        stats         ProcessorStats
        mutex         sync.RWMutex

        // Métriques de performance
        lastMinuteDetections []time.Time
}

func NewEventProcessor() EventProcessor <span class="cov0" title="0">{
        ep := &amp;eventProcessor{
                detectors:            make(map[string]Detector),
                lastMinuteDetections: make([]time.Time, 0),
        }

        // Enregistrement des détecteurs par défaut
        ep.RegisterDetector("motion", &amp;MotionDetector{})
        ep.RegisterDetector("intrusion", &amp;IntrusionDetector{})

        // Nettoyage périodique des métriques
        go ep.cleanupMetrics()

        return ep
}</span>

func (ep *eventProcessor) ProcessDetection(detection Detection) []Alert <span class="cov8" title="1">{
        ep.mutex.Lock()
        defer ep.mutex.Unlock()

        // Mise à jour des statistiques
        ep.stats.TotalDetections++
        ep.stats.LastProcessed = time.Now()
        ep.lastMinuteDetections = append(ep.lastMinuteDetections, time.Now())

        var alerts []Alert

        // Test de chaque détecteur
        for name, detector := range ep.detectors </span><span class="cov8" title="1">{
                if detector.ShouldAlert(detection) </span><span class="cov8" title="1">{
                        alert := detector.CreateAlert(detection)
                        alert.ID = uuid.New().String()
                        alert.Timestamp = time.Now()

                        alerts = append(alerts, alert)
                        ep.stats.TotalAlerts++

                        log.Printf("Alert générée par %s: %s", name, alert.Message)

                        // Callback vers WebSocket
                        if ep.alertCallback != nil </span><span class="cov8" title="1">{
                                ep.alertCallback(alert)
                        }</span>
                }
        }

        <span class="cov8" title="1">return alerts</span>
}

func (ep *eventProcessor) RegisterDetector(name string, detector Detector) <span class="cov8" title="1">{
        ep.mutex.Lock()
        defer ep.mutex.Unlock()

        ep.detectors[name] = detector
        log.Printf("Détecteur enregistré: %s", name)
}</span>

func (ep *eventProcessor) SetAlertCallback(callback func(Alert)) <span class="cov8" title="1">{
        ep.mutex.Lock()
        defer ep.mutex.Unlock()

        ep.alertCallback = callback
}</span>

func (ep *eventProcessor) GetStats() ProcessorStats <span class="cov8" title="1">{
        ep.mutex.RLock()
        defer ep.mutex.RUnlock()

        // Calcul du taux de traitement
        now := time.Now()
        cutoff := now.Add(-time.Minute)
        recentDetections := 0

        for _, t := range ep.lastMinuteDetections </span><span class="cov8" title="1">{
                if t.After(cutoff) </span><span class="cov8" title="1">{
                        recentDetections++
                }</span>
        }

        <span class="cov8" title="1">stats := ep.stats
        stats.ProcessingRate = float64(recentDetections) / 60.0 // détections/seconde

        return stats</span>
}

func (ep *eventProcessor) cleanupMetrics() <span class="cov8" title="1">{
        ticker := time.NewTicker(time.Minute)
        defer ticker.Stop()

        for range ticker.C </span><span class="cov0" title="0">{
                ep.mutex.Lock()
                cutoff := time.Now().Add(-time.Minute)
                filtered := make([]time.Time, 0)

                for _, t := range ep.lastMinuteDetections </span><span class="cov0" title="0">{
                        if t.After(cutoff) </span><span class="cov0" title="0">{
                                filtered = append(filtered, t)
                        }</span>
                }

                <span class="cov0" title="0">ep.lastMinuteDetections = filtered
                ep.mutex.Unlock()</span>
        }
}

// Détecteurs concrets

type MotionDetector struct{}

func (md *MotionDetector) ShouldAlert(detection Detection) bool <span class="cov0" title="0">{
        return detection.Type == DetectionTypeMotion &amp;&amp; detection.Confidence &gt; 0.7
}</span>

func (md *MotionDetector) CreateAlert(detection Detection) Alert <span class="cov0" title="0">{
        return Alert{
                CameraID:  detection.CameraID,
                Type:      AlertTypeMotion,
                Level:     AlertLevelInfo,
                Message:   fmt.Sprintf("Mouvement détecté (confiance: %.2f)", detection.Confidence),
                Detection: &amp;detection,
        }
}</span>

type IntrusionDetector struct{}

func (id *IntrusionDetector) ShouldAlert(detection Detection) bool <span class="cov0" title="0">{
        return detection.Type == DetectionTypeIntrusion ||
                (detection.Type == DetectionTypePerson &amp;&amp; detection.Confidence &gt; 0.8)
}</span>

func (id *IntrusionDetector) CreateAlert(detection Detection) Alert <span class="cov0" title="0">{
        level := AlertLevelWarning
        if detection.Type == DetectionTypeIntrusion </span><span class="cov0" title="0">{
                level = AlertLevelCritical
        }</span>

        <span class="cov0" title="0">return Alert{
                CameraID:  detection.CameraID,
                Type:      AlertTypeIntrusion,
                Level:     level,
                Message:   fmt.Sprintf("Intrusion possible détectée (confiance: %.2f)", detection.Confidence),
                Detection: &amp;detection,
        }</span>
}

// NewEventProcessorEmpty crée un EventProcessor sans détecteurs par défaut (pour les tests)
func NewEventProcessorEmpty() EventProcessor <span class="cov8" title="1">{
        ep := &amp;eventProcessor{
                detectors:            make(map[string]Detector),
                lastMinuteDetections: make([]time.Time, 0),
        }

        // Nettoyage périodique des métriques
        go ep.cleanupMetrics()

        return ep
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package vision

import (
        "fmt"
        "math/rand"
        "surveillance-core/internal/core"
        "sync"
        "time"

        "github.com/google/uuid"
)

type Client interface {
        StartStream(cameraID string) (&lt;-chan core.Frame, error)
        StopStream(cameraID string) error
        GetStreamStatus(cameraID string) StreamStatus
        IsConnected() bool
}

type StreamStatus string

const (
        StreamStatusStopped  StreamStatus = "stopped"
        StreamStatusStarting StreamStatus = "starting"
        StreamStatusActive   StreamStatus = "active"
        StreamStatusError    StreamStatus = "error"
)

type mockClient struct {
        streams map[string]*mockStream
        mutex   sync.RWMutex
}

type mockStream struct {
        cameraID   string
        status     StreamStatus
        framesChan chan core.Frame
        stopChan   chan bool
        ticker     *time.Ticker
}

func NewMockClient() Client <span class="cov8" title="1">{
        return &amp;mockClient{
                streams: make(map[string]*mockStream),
        }
}</span>

func (mc *mockClient) StartStream(cameraID string) (&lt;-chan core.Frame, error) <span class="cov8" title="1">{
        mc.mutex.Lock()
        defer mc.mutex.Unlock()

        // Vérifier si le stream existe déjà
        if stream, exists := mc.streams[cameraID]; exists </span><span class="cov8" title="1">{
                if stream.status == StreamStatusActive </span><span class="cov8" title="1">{
                        return stream.framesChan, nil
                }</span>
                // Arrêter l'ancien stream s'il existe
                <span class="cov0" title="0">mc.stopStreamInternal(cameraID)</span>
        }

        // Créer nouveau stream
        <span class="cov8" title="1">stream := &amp;mockStream{
                cameraID:   cameraID,
                status:     StreamStatusStarting,
                framesChan: make(chan core.Frame, 10),
                stopChan:   make(chan bool),
                ticker:     time.NewTicker(time.Second / 15), // 15 FPS
        }

        mc.streams[cameraID] = stream

        // Démarrer le générateur de frames en goroutine
        go mc.generateFrames(stream)

        stream.status = StreamStatusActive
        fmt.Printf("Stream démarré pour caméra: %s\n", cameraID)

        return stream.framesChan, nil</span>
}

func (mc *mockClient) StopStream(cameraID string) error <span class="cov8" title="1">{
        mc.mutex.Lock()
        defer mc.mutex.Unlock()

        return mc.stopStreamInternal(cameraID)
}</span>

func (mc *mockClient) stopStreamInternal(cameraID string) error <span class="cov8" title="1">{
        stream, exists := mc.streams[cameraID]
        if !exists </span><span class="cov8" title="1">{
                return fmt.Errorf("stream non trouvé pour caméra: %s", cameraID)
        }</span>

        // Arrêter le générateur
        <span class="cov8" title="1">stream.ticker.Stop()
        close(stream.stopChan)
        close(stream.framesChan)

        delete(mc.streams, cameraID)
        fmt.Printf("Stream arrêté pour caméra: %s\n", cameraID)

        return nil</span>
}

func (mc *mockClient) GetStreamStatus(cameraID string) StreamStatus <span class="cov8" title="1">{
        mc.mutex.RLock()
        defer mc.mutex.RUnlock()

        if stream, exists := mc.streams[cameraID]; exists </span><span class="cov8" title="1">{
                return stream.status
        }</span>
        <span class="cov8" title="1">return StreamStatusStopped</span>
}

func (mc *mockClient) IsConnected() bool <span class="cov8" title="1">{
        return true // Mock toujours connecté
}</span>

func (mc *mockClient) generateFrames(stream *mockStream) <span class="cov8" title="1">{
        detectionCounter := 0

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-stream.stopChan:<span class="cov8" title="1">
                        return</span>

                case &lt;-stream.ticker.C:<span class="cov8" title="1">
                        // Générer frame mock
                        imageData := mc.generateMockImageData()
                        frame := core.Frame{
                                CameraID:  stream.cameraID,
                                Data:      imageData,
                                Width:     1920,
                                Height:    1080,
                                Format:    "jpeg",
                                Timestamp: time.Now(),
                                Size:      len(imageData), // ← CORRECTION: utiliser la vraie taille
                        }

                        // Envoyer frame (non-bloquant)
                        select </span>{
                        case stream.framesChan &lt;- frame:<span class="cov8" title="1">
                                // Simuler détections occasionnelles
                                detectionCounter++
                                if detectionCounter%45 == 0 </span><span class="cov0" title="0">{ // Toutes les 3 secondes à 15fps
                                        mc.simulateDetection(stream.cameraID)
                                }</span>
                        default:<span class="cov0" title="0"></span>
                                // Canal plein, ignorer cette frame
                        }
                }
        }
}

func (mc *mockClient) generateMockImageData() []byte <span class="cov8" title="1">{
        // Génère des données d'image factices
        size := 65536 + rand.Intn(32768) // Entre 64KB et 96KB
        data := make([]byte, size)

        // Remplir avec du bruit pseudo-aléatoire pour simuler une image JPEG
        for i := range data </span><span class="cov8" title="1">{
                data[i] = byte(rand.Intn(256))
        }</span>

        <span class="cov8" title="1">return data</span>
}

func (mc *mockClient) simulateDetection(cameraID string) <span class="cov0" title="0">{
        // Simuler différents types de détections
        detectionTypes := []core.DetectionType{
                core.DetectionTypeMotion,
                core.DetectionTypePerson,
                core.DetectionTypeVehicle,
        }

        detectionType := detectionTypes[rand.Intn(len(detectionTypes))]
        confidence := 0.6 + rand.Float32()*0.4 // Entre 0.6 et 1.0

        detection := core.Detection{
                ID:         uuid.New().String(),
                CameraID:   cameraID,
                Type:       detectionType,
                Confidence: confidence,
                BBox: core.BoundingBox{
                        X:      rand.Intn(1600),
                        Y:      rand.Intn(900),
                        Width:  100 + rand.Intn(300),
                        Height: 100 + rand.Intn(300),
                },
                Timestamp: time.Now(),
                Metadata: map[string]string{
                        "source":        "mock_detector",
                        "model_version": "1.0.0",
                },
        }

        fmt.Printf("🔍 Détection simulée: %s sur %s (confiance: %.2f)\n",
                detectionType, cameraID, confidence)

        // Dans un vrai système, ceci irait vers l'EventProcessor
        // Pour le mock, on utilise la variable pour éviter l'erreur de compilation
        _ = detection // Utilisation explicite pour éviter l'erreur "declared and not used"
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">// internal/websocket/hub.go
package websocket

import (
        "encoding/json"
        "fmt"
        "log"
        "net/http"
        "sync"
        "time"

        "github.com/gorilla/websocket"
)

var upgrader = websocket.Upgrader{
        CheckOrigin: func(r *http.Request) bool <span class="cov0" title="0">{
                return true // Permettre toutes les origines pour le dev
        }</span>,
}

type Hub struct {
        clients    map[*Client]bool
        broadcast  chan Message
        register   chan *Client
        unregister chan *Client
        mutex      sync.RWMutex
}

type Client struct {
        hub  *Hub
        conn *websocket.Conn
        send chan Message
        id   string
}

type Message struct {
        Type      string      `json:"type"`
        Data      interface{} `json:"data"`
        Timestamp time.Time   `json:"timestamp"`
}

type Handler struct {
        hub *Hub
}

func NewHub() *Hub <span class="cov0" title="0">{
        return &amp;Hub{
                clients:    make(map[*Client]bool),
                broadcast:  make(chan Message, 256),
                register:   make(chan *Client),
                unregister: make(chan *Client),
        }
}</span>

func NewHandler(hub *Hub) *Handler <span class="cov0" title="0">{
        return &amp;Handler{hub: hub}
}</span>

func (h *Hub) Run() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                select </span>{
                case client := &lt;-h.register:<span class="cov0" title="0">
                        h.mutex.Lock()
                        h.clients[client] = true
                        h.mutex.Unlock()

                        log.Printf("Client connecté: %s", client.id)

                        // Envoyer message de bienvenue
                        welcome := Message{
                                Type:      "connection",
                                Data:      map[string]string{"status": "connected", "client_id": client.id},
                                Timestamp: time.Now(),
                        }
                        select </span>{
                        case client.send &lt;- welcome:<span class="cov0" title="0"></span>
                        default:<span class="cov0" title="0">
                                h.removeClient(client)</span>
                        }

                case client := &lt;-h.unregister:<span class="cov0" title="0">
                        h.removeClient(client)</span>

                case message := &lt;-h.broadcast:<span class="cov0" title="0">
                        message.Timestamp = time.Now()
                        h.mutex.RLock()
                        for client := range h.clients </span><span class="cov0" title="0">{
                                select </span>{
                                case client.send &lt;- message:<span class="cov0" title="0"></span>
                                default:<span class="cov0" title="0">
                                        h.mutex.RUnlock()
                                        h.removeClient(client)
                                        h.mutex.RLock()</span>
                                }
                        }
                        <span class="cov0" title="0">h.mutex.RUnlock()</span>
                }
        }
}

func (h *Hub) removeClient(client *Client) <span class="cov0" title="0">{
        h.mutex.Lock()
        defer h.mutex.Unlock()

        if _, ok := h.clients[client]; ok </span><span class="cov0" title="0">{
                delete(h.clients, client)
                close(client.send)
                client.conn.Close()
                log.Printf("Client déconnecté: %s", client.id)
        }</span>
}

func (h *Hub) Broadcast(message Message) <span class="cov0" title="0">{
        select </span>{
        case h.broadcast &lt;- message:<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0">
                log.Println("Canal broadcast plein, message abandonné")</span>
        }
}

func (h *Hub) GetClientCount() int <span class="cov0" title="0">{
        h.mutex.RLock()
        defer h.mutex.RUnlock()
        return len(h.clients)
}</span>

func (handler *Handler) HandleWebSocket(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        conn, err := upgrader.Upgrade(w, r, nil)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Erreur upgrade WebSocket: %v", err)
                return
        }</span>

        <span class="cov0" title="0">clientID := r.URL.Query().Get("client_id")
        if clientID == "" </span><span class="cov0" title="0">{
                clientID = generateClientID()
        }</span>

        <span class="cov0" title="0">client := &amp;Client{
                hub:  handler.hub,
                conn: conn,
                send: make(chan Message, 256),
                id:   clientID,
        }

        client.hub.register &lt;- client

        // Démarrer les goroutines de lecture/écriture
        go client.writePump()
        go client.readPump()</span>
}

const (
        writeWait      = 10 * time.Second
        pongWait       = 60 * time.Second
        pingPeriod     = (pongWait * 9) / 10
        maxMessageSize = 512
)

func (c *Client) readPump() <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                c.hub.unregister &lt;- c
        }</span>()

        <span class="cov0" title="0">c.conn.SetReadLimit(maxMessageSize)
        c.conn.SetReadDeadline(time.Now().Add(pongWait))
        c.conn.SetPongHandler(func(string) error </span><span class="cov0" title="0">{
                c.conn.SetReadDeadline(time.Now().Add(pongWait))
                return nil
        }</span>)

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                _, message, err := c.conn.ReadMessage()
                if err != nil </span><span class="cov0" title="0">{
                        if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) </span><span class="cov0" title="0">{
                                log.Printf("Erreur WebSocket: %v", err)
                        }</span>
                        <span class="cov0" title="0">break</span>
                }

                // Traitement des messages entrants du client
                <span class="cov0" title="0">var msg Message
                if err := json.Unmarshal(message, &amp;msg); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Erreur parsing message: %v", err)
                        continue</span>
                }

                // Echo pour test ou traitement spécifique
                <span class="cov0" title="0">log.Printf("Message reçu de %s: %s", c.id, msg.Type)</span>
        }
}

func (c *Client) writePump() <span class="cov0" title="0">{
        ticker := time.NewTicker(pingPeriod)
        defer func() </span><span class="cov0" title="0">{
                ticker.Stop()
                c.conn.Close()
        }</span>()

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                select </span>{
                case message, ok := &lt;-c.send:<span class="cov0" title="0">
                        c.conn.SetWriteDeadline(time.Now().Add(writeWait))
                        if !ok </span><span class="cov0" title="0">{
                                c.conn.WriteMessage(websocket.CloseMessage, []byte{})
                                return
                        }</span>

                        <span class="cov0" title="0">data, err := json.Marshal(message)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("Erreur marshaling message: %v", err)
                                continue</span>
                        }

                        <span class="cov0" title="0">if err := c.conn.WriteMessage(websocket.TextMessage, data); err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>

                case &lt;-ticker.C:<span class="cov0" title="0">
                        c.conn.SetWriteDeadline(time.Now().Add(writeWait))
                        if err := c.conn.WriteMessage(websocket.PingMessage, nil); err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
        }
}

func generateClientID() string <span class="cov0" title="0">{
        return fmt.Sprintf("client_%d", time.Now().UnixNano())
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
